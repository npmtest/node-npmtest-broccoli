{"/home/travis/build/npmtest/node-npmtest-broccoli/test.js":"/* istanbul instrument in package npmtest_broccoli */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-broccoli/lib.npmtest_broccoli.js":"/* istanbul instrument in package npmtest_broccoli */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_broccoli = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_broccoli = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-broccoli/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-broccoli && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_broccoli */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_broccoli\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_broccoli.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_broccoli.rollup.js'] =\n            local.assetsDict['/assets.npmtest_broccoli.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_broccoli.__dirname +\n                    '/lib.npmtest_broccoli.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-broccoli/node_modules/broccoli/lib/index.js":"exports.Builder = require('./builder')\nexports.loadBrocfile = require('./load_brocfile')\nexports.server = require('./server')\nexports.getMiddleware = require('./middleware')\nexports.Watcher = require('./watcher')\nexports.WatcherAdapter = require('./watcher_adapter')\nexports.cli = require('./cli')\n","/home/travis/build/npmtest/node-npmtest-broccoli/node_modules/broccoli/lib/builder.js":"'use strict'\n\nvar path = require('path')\nvar fs = require('fs')\nvar RSVP = require('rsvp')\nvar tmp = require('tmp')\nvar rimraf = require('rimraf')\nvar underscoreString = require('underscore.string')\nvar WatchedDir = require('broccoli-source').WatchedDir\nvar broccoliNodeInfo = require('broccoli-node-info')\n\n// Clean up left-over temporary directories on uncaught exception.\ntmp.setGracefulCleanup()\n\n\n// For an explanation and reference of the API that we use to communicate with\n// nodes (__broccoliFeatures__ and __broccoliGetInfo__), see\n// https://github.com/broccolijs/broccoli/blob/master/docs/node-api.md\n\n\n// Build a graph of nodes, referenced by its final output node. Example:\n//\n// var builder = new Builder(outputNode)\n// builder.build()\n//   .then(function() {\n//     // Build output has been written to builder.outputPath\n//   })\n//   // To rebuild, call builder.build() repeatedly\n//   .finally(function() {\n//     // Delete temporary directories\n//     builder.cleanup()\n//   })\n//\n// Note that the API of this Builder may change between minor Broccoli\n// versions. Backwards compatibility is only guaranteed for plugins, so any\n// plugin that works with Broccoli 1.0 will work with 1.x.\n\nmodule.exports = Builder\nfunction Builder(outputNode, options) {\n  if (options == null) options = {}\n\n  this.outputNode = outputNode\n  this.tmpdir = options.tmpdir // can be null\n\n  this.unwatchedPaths = []\n  this.watchedPaths = []\n\n  // nodeWrappers store additional bookkeeping information, such as paths.\n  // This array contains them in topological (build) order.\n  this.nodeWrappers = []\n  // This populates this.nodeWrappers as a side effect\n  this.outputNodeWrapper = this.makeNodeWrapper(this.outputNode)\n\n  // Catching missing directories here helps prevent later errors when we set\n  // up the watcher.\n  this.checkInputPathsExist()\n\n  this.setupTmpDirs()\n\n  // Now that temporary directories are set up, we need to run the rest of the\n  // constructor in a try/catch block to clean them up if necessary.\n  try {\n\n    this.setupNodes()\n    this.outputPath = this.outputNodeWrapper.outputPath\n    this.buildId = 0\n\n  } catch (e) {\n    this.cleanup()\n    throw e\n  }\n}\n\nRSVP.EventTarget.mixin(Builder.prototype)\n\n// Trigger a (re)build.\n//\n// Returns a promise that resolves when the build has finished. If there is a\n// build error, the promise is rejected with a Builder.BuildError instance.\n// This method will never throw, and it will never be rejected with anything\n// other than a BuildError.\nBuilder.prototype.build = function() {\n  var self = this\n  this.buildId++\n  var promise = RSVP.resolve()\n  this.nodeWrappers.forEach(function(nw) {\n    // We use `.forEach` instead of `for` to close nested functions over `nw`\n\n    // Wipe all buildState objects at the beginning of the build\n    nw.buildState = {}\n\n    promise = promise\n      .then(function() {\n        // We use a nested .then/.catch so that the .catch can only catch errors\n        // from this node, but not from previous nodes.\n        return RSVP.resolve()\n          .then(function() {\n            self.trigger('beginNode', nw)\n          })\n          .then(function() {\n            return nw.build()\n          })\n          .finally(function() {\n            self.trigger('endNode', nw)\n          })\n          .catch(function(err) {\n            throw new BuildError(err, nw)\n          })\n      })\n  })\n  return promise\n}\n\n// Destructor-like method. Cleanup is synchronous at the moment, but in the\n// future we might change it to return a promise.\nBuilder.prototype.cleanup = function() {\n  this.builderTmpDirCleanup()\n}\n\n// This method recursively traverses the node graph and returns a nodeWrapper.\n// The nodeWrapper graph parallels the node graph 1:1.\nBuilder.prototype.makeNodeWrapper = function(node, _stack) {\n  if (_stack == null) _stack = []\n  var self = this\n\n  // Dedupe nodes reachable through multiple paths\n  for (var i = 0; i < this.nodeWrappers.length; i++) {\n    if (this.nodeWrappers[i].originalNode === node) {\n      return this.nodeWrappers[i]\n    }\n  }\n\n  // Turn string nodes into WatchedDir nodes\n  var originalNode = node // keep original (possibly string) node around for deduping\n  if (typeof node === 'string') {\n    node = new WatchedDir(node, { annotation: 'string node' })\n  }\n\n  // Call node.__broccoliGetInfo__()\n  var nodeInfo\n  try {\n    nodeInfo = broccoliNodeInfo.getNodeInfo(node)\n  } catch (e) {\n    if (!(e instanceof broccoliNodeInfo.InvalidNodeError)) throw e\n    // We don't have the instantiation stack of an invalid node, so to aid\n    // debugging, we instead report its parent node\n    var messageSuffix = (_stack.length > 0) ?\n      '\\nused as input node to ' + _stack[_stack.length-1].label +\n        _stack[_stack.length-1].formatInstantiationStackForTerminal()\n      : '\\nused as output node'\n    throw new broccoliNodeInfo.InvalidNodeError(e.message + messageSuffix)\n  }\n\n  // Compute label, like \"Funnel (test suite)\"\n  var label = nodeInfo.name\n  var labelExtras = []\n  if (nodeInfo.nodeType === 'source') labelExtras.push(nodeInfo.sourceDirectory)\n  if (nodeInfo.annotation != null) labelExtras.push(nodeInfo.annotation)\n  if (labelExtras.length > 0) label += ' (' + labelExtras.join('; ') + ')'\n\n  // We start constructing the nodeWrapper here because we'll need the partial\n  // nodeWrapper for the _stack. Later we'll add more properties.\n  var nodeWrapper = nodeInfo.nodeType === 'transform' ?\n    new TransformNodeWrapper : new SourceNodeWrapper\n  nodeWrapper.nodeInfo = nodeInfo\n  nodeWrapper.originalNode = originalNode\n  nodeWrapper.node = node\n  nodeWrapper.label = label\n\n  // Detect cycles\n  for (i = 0; i < _stack.length; i++) {\n    if (_stack[i].node === originalNode) {\n      var cycleMessage = 'Cycle in node graph: '\n      for (var j = i; j < _stack.length; j++) {\n        cycleMessage += _stack[j].label + ' -> '\n      }\n      cycleMessage += nodeWrapper.label\n      throw new BuilderError(cycleMessage)\n    }\n  }\n\n  // For 'transform' nodes, recurse into the input nodes; for 'source' nodes,\n  // record paths.\n  var inputNodeWrappers = []\n  if (nodeInfo.nodeType === 'transform') {\n    var newStack = _stack.concat([nodeWrapper])\n    inputNodeWrappers = nodeInfo.inputNodes.map(function(inputNode) {\n      return self.makeNodeWrapper(inputNode, newStack)\n    })\n  } else { // nodeType === 'source'\n    if (nodeInfo.watched) {\n      this.watchedPaths.push(nodeInfo.sourceDirectory)\n    } else {\n      this.unwatchedPaths.push(nodeInfo.sourceDirectory)\n    }\n  }\n\n  // For convenience, all nodeWrappers get an `inputNodeWrappers` array; for\n  // 'source' nodes it's empty.\n  nodeWrapper.inputNodeWrappers = inputNodeWrappers\n\n  nodeWrapper.id = this.nodeWrappers.length\n\n  // this.nodeWrappers will contain all the node wrappers in topological\n  // order, i.e. each node comes after all its input nodes.\n  //\n  // It's unfortunate that we're mutating this.nodeWrappers as a side effect,\n  // but since we work backwards from the output node to discover all the\n  // input nodes, it's harder to do a side-effect-free topological sort.\n  this.nodeWrappers.push(nodeWrapper)\n\n  return nodeWrapper\n}\n\nBuilder.prototype.features = broccoliNodeInfo.features\n\nBuilder.prototype.checkInputPathsExist = function() {\n  // We might consider checking this.unwatchedPaths as well.\n  for (var i = 0; i < this.watchedPaths.length; i++) {\n    var isDirectory\n    try {\n      isDirectory = fs.statSync(this.watchedPaths[i]).isDirectory()\n    } catch (err) {\n      throw new Builder.BuilderError('Directory not found: ' + this.watchedPaths[i])\n    }\n    if (!isDirectory) {\n      throw new Builder.BuilderError('Not a directory: ' + this.watchedPaths[i])\n    }\n  }\n};\n\nBuilder.prototype.setupTmpDirs = function() {\n  // Create temporary directories for each node:\n  //\n  //   out-01-someplugin/\n  //   out-02-otherplugin/\n  //   cache-01-someplugin/\n  //   cache-02-otherplugin/\n  //\n  // Here's an alternative directory structure we might consider (it's not\n  // clear which structure makes debugging easier):\n  //\n  //   01-someplugin/\n  //     out/\n  //     cache/\n  //     in-1 -> ... // symlink for convenience\n  //     in-2 -> ...\n  //   02-otherplugin/\n  //     ...\n  var tmpobj = tmp.dirSync({ prefix: 'broccoli-', unsafeCleanup: true, dir: this.tmpdir })\n  this.builderTmpDir = tmpobj.name\n  this.builderTmpDirCleanup = tmpobj.removeCallback\n  for (var i = 0; i < this.nodeWrappers.length; i++) {\n    var nodeWrapper = this.nodeWrappers[i]\n    if (nodeWrapper.nodeInfo.nodeType === 'transform') {\n      nodeWrapper.inputPaths = nodeWrapper.inputNodeWrappers.map(function(nw) {\n        return nw.outputPath\n      })\n      nodeWrapper.outputPath = this.mkTmpDir(nodeWrapper, 'out')\n\n      if (nodeWrapper.nodeInfo.needsCache) {\n        nodeWrapper.cachePath = this.mkTmpDir(nodeWrapper, 'cache')\n      }\n    } else { // nodeType === 'source'\n      // We could name this .sourcePath, but with .outputPath the code is simpler.\n      nodeWrapper.outputPath = nodeWrapper.nodeInfo.sourceDirectory\n    }\n  }\n}\n\n\n// Create temporary directory, like\n// /tmp/broccoli-9rLfJh/out-067-merge_trees_vendor_packages\n// type is 'out' or 'cache'\nBuilder.prototype.mkTmpDir = function(nodeWrapper, type) {\n  var nameAndAnnotation = nodeWrapper.nodeInfo.name + ' ' + (nodeWrapper.nodeInfo.annotation || '')\n  // slugify turns fooBar into foobar, so we call underscored first to\n  // preserve word boundaries\n  var suffix = underscoreString.underscored(nameAndAnnotation.substr(0, 60))\n  suffix = underscoreString.slugify(suffix).replace(/-/g, '_')\n  // 1 .. 147 -> '001' .. '147'\n  var paddedId = underscoreString.pad('' + nodeWrapper.id, ('' + this.nodeWrappers.length).length, '0')\n  var dirname = type + '-' + paddedId + '-' + suffix\n  var tmpDir = path.join(this.builderTmpDir, dirname)\n  fs.mkdirSync(tmpDir)\n  return tmpDir\n}\n\nBuilder.prototype.setupNodes = function() {\n  for (var i = 0; i < this.nodeWrappers.length; i++) {\n    var nw = this.nodeWrappers[i]\n    try {\n      nw.setup(this.features)\n    } catch (err) {\n      throw new NodeSetupError(err, nw)\n    }\n  }\n}\n\n\n// Base class for builder errors\nBuilder.BuilderError = BuilderError\nBuilderError.prototype = Object.create(Error.prototype)\nBuilderError.prototype.constructor = BuilderError\nfunction BuilderError(message) {\n  // Subclassing Error in ES5 is non-trivial because reasons, so we need this\n  // extra constructor logic from http://stackoverflow.com/a/17891099/525872.\n  // Note that ES5 subclasses of BuilderError don't in turn need any special\n  // code.\n  var temp = Error.apply(this, arguments)\n  // Need to assign temp.name for correct error class in .stack and .message\n  temp.name = this.name = this.constructor.name\n  this.stack = temp.stack\n  this.message = temp.message\n}\n\nBuilder.InvalidNodeError = broccoliNodeInfo.InvalidNodeError\n\nBuilder.NodeSetupError = NodeSetupError\nNodeSetupError.prototype = Object.create(BuilderError.prototype)\nNodeSetupError.prototype.constructor = NodeSetupError\nfunction NodeSetupError(originalError, nodeWrapper) {\n  if (nodeWrapper == null) { // Chai calls new NodeSetupError() :(\n    BuilderError.call(this)\n    return\n  }\n  originalError = wrapPrimitiveErrors(originalError)\n  var message = originalError.message +\n    '\\nat ' + nodeWrapper.label +\n    nodeWrapper.formatInstantiationStackForTerminal()\n  BuilderError.call(this, message)\n  // The stack will have the original exception name, but that's OK\n  this.stack = originalError.stack\n}\n\nBuilder.BuildError = BuildError\nBuildError.prototype = Object.create(BuilderError.prototype)\nBuildError.prototype.constructor = BuildError\nfunction BuildError(originalError, nodeWrapper) {\n  if (nodeWrapper == null) { // for Chai\n    BuilderError.call(this)\n    return\n  }\n\n  originalError = wrapPrimitiveErrors(originalError)\n\n  // Create heavily augmented message for easy printing to the terminal. Web\n  // interfaces should refer to broccoliPayload.originalError.message instead.\n  var filePart = ''\n  if (originalError.file != null) {\n    filePart = originalError.file\n    if (originalError.line != null) {\n      filePart += ':' + originalError.line\n      if (originalError.column != null) {\n        // .column is zero-indexed\n        filePart += ':' + (originalError.column + 1)\n      }\n    }\n    filePart += ': '\n  }\n  var instantiationStack = ''\n  if (originalError.file == null) {\n    // We want to report the instantiation stack only for \"unexpected\" errors\n    // (bugs, internal errors), but not for compiler errors and such. For now,\n    // the presence of `.file` serves as a heuristic to distinguish between\n    // those cases.\n    instantiationStack = nodeWrapper.formatInstantiationStackForTerminal()\n  }\n  var message = filePart + originalError.message +\n    (originalError.treeDir ? '\\n        in ' + originalError.treeDir : '') +\n    '\\n        at ' + nodeWrapper.label +\n    instantiationStack\n\n  BuilderError.call(this, message)\n  this.stack = originalError.stack\n\n  // This error API can change between minor Broccoli version bumps\n  this.broccoliPayload = {\n    originalError: originalError, // guaranteed to be error object, not primitive\n    originalMessage: originalError.message,\n    // node info\n    nodeId: nodeWrapper.id,\n    nodeLabel: nodeWrapper.label,\n    nodeName: nodeWrapper.nodeInfo.name,\n    nodeAnnotation: nodeWrapper.nodeInfo.annotation,\n    instantiationStack: nodeWrapper.nodeInfo.instantiationStack,\n    // error location (if any)\n    location: {\n      file: originalError.file,\n      treeDir: originalError.treeDir,\n      line: originalError.line,\n      column: originalError.column\n    }\n  }\n}\n\n\nBuilder.NodeWrapper = NodeWrapper\nfunction NodeWrapper() {\n  this.buildState = {}\n}\n\nBuilder.TransformNodeWrapper = TransformNodeWrapper\nTransformNodeWrapper.prototype = Object.create(NodeWrapper.prototype)\nTransformNodeWrapper.prototype.constructor = TransformNodeWrapper\nfunction TransformNodeWrapper() {\n  NodeWrapper.apply(this, arguments)\n}\n\nBuilder.SourceNodeWrapper = SourceNodeWrapper\nSourceNodeWrapper.prototype = Object.create(NodeWrapper.prototype)\nSourceNodeWrapper.prototype.constructor = SourceNodeWrapper\nfunction SourceNodeWrapper() {\n  NodeWrapper.apply(this, arguments)\n}\n\nTransformNodeWrapper.prototype.setup = function(features) {\n  this.nodeInfo.setup(features, {\n    inputPaths: this.inputPaths,\n    outputPath: this.outputPath,\n    cachePath: this.cachePath\n  })\n  this.callbackObject = this.nodeInfo.getCallbackObject()\n}\n\nSourceNodeWrapper.prototype.setup = function(features) {\n}\n\n// Call node.build(), plus bookkeeping\nTransformNodeWrapper.prototype.build = function() {\n  var self = this\n\n  var startTime = process.hrtime()\n\n  if (!this.nodeInfo.persistentOutput) {\n    rimraf.sync(this.outputPath)\n    fs.mkdirSync(this.outputPath)\n  }\n\n  return RSVP.resolve(self.callbackObject.build())\n\n    .then(function() {\n      var now = process.hrtime()\n      // Build time in milliseconds\n      self.buildState.selfTime = 1000 * ((now[0] - startTime[0]) + (now[1] - startTime[1]) / 1e9)\n      self.buildState.totalTime = self.buildState.selfTime\n      for (var i = 0; i < self.inputNodeWrappers.length; i++) {\n        self.buildState.totalTime += self.inputNodeWrappers[i].buildState.totalTime\n      }\n    })\n}\n\nSourceNodeWrapper.prototype.build = function() {\n  // We only check here that the sourceDirectory exists and is a directory\n  try {\n    if (!fs.statSync(this.nodeInfo.sourceDirectory).isDirectory()) {\n      throw new Error('Not a directory')\n    }\n  } catch (err) { // stat might throw, or we might throw\n    err.file = this.nodeInfo.sourceDirectory\n    // fs.stat augments error message with file name, but that's redundant\n    // with our err.file, so we strip it\n    err.message = err.message.replace(/, stat '[^'\\n]*'$/m, '')\n    throw err\n  }\n\n  this.buildState.selfTime = 0\n  this.buildState.totalTime = 0\n}\n\nTransformNodeWrapper.prototype.toString = function() {\n  var hint = this.label\n  hint = this.label\n  if (this.inputNodeWrappers) { // a bit defensive to deal with partially-constructed node wrappers\n    hint += ' inputNodeWrappers:[' + this.inputNodeWrappers.map(function(nw) { return nw.id }) + ']'\n  }\n  hint += ' at ' + this.outputPath\n  if (this.buildState.selfTime != null) {\n    hint += ' (' + Math.round(this.buildState.selfTime) + ' ms)'\n  }\n  return '[NodeWrapper:' + this.id + ' ' + hint + ']'\n}\n\nSourceNodeWrapper.prototype.toString = function() {\n  var hint = this.nodeInfo.sourceDirectory +\n    (this.nodeInfo.watched ? '' : ' (unwatched)')\n  return '[NodeWrapper:' + this.id + ' ' + hint + ']'\n}\n\nNodeWrapper.prototype.toJSON = function() {\n  return undefinedToNull({\n    id: this.id,\n    nodeInfo: this.nodeInfoToJSON(),\n    buildState: this.buildState,\n    label: this.label,\n    inputNodeWrappers: this.inputNodeWrappers.map(function(nw) { return nw.id }),\n    cachePath: this.cachePath,\n    outputPath: this.outputPath\n    // leave out node, originalNode, inputPaths (redundant), build\n  })\n}\n\nTransformNodeWrapper.prototype.nodeInfoToJSON = function() {\n  return undefinedToNull({\n    nodeType: 'transform',\n    name: this.nodeInfo.name,\n    annotation: this.nodeInfo.annotation,\n    persistentOutput: this.nodeInfo.persistentOutput,\n    needsCache: this.nodeInfo.needsCache\n    // leave out instantiationStack (too long), inputNodes, and callbacks\n  })\n}\n\nSourceNodeWrapper.prototype.nodeInfoToJSON = function() {\n  return undefinedToNull({\n    nodeType: 'source',\n    sourceDirectory: this.nodeInfo.sourceDirectory,\n    watched: this.nodeInfo.watched,\n    name: this.nodeInfo.name,\n    annotation: this.nodeInfo.annotation\n    // leave out instantiationStack\n  })\n}\n\nNodeWrapper.prototype.formatInstantiationStackForTerminal = function() {\n  return '\\n-~- created here: -~-\\n' + this.nodeInfo.instantiationStack + '\\n-~- (end) -~-'\n}\n\n\n// Replace all `undefined` values with `null`, so that they show up in JSON output\nfunction undefinedToNull(obj) {\n  for (var key in obj) {\n    if (obj.hasOwnProperty(key) && obj[key] === undefined) {\n      obj[key] = null\n    }\n  }\n  return obj\n}\n\nfunction wrapPrimitiveErrors(err) {\n  if (err !== null && typeof err === 'object') {\n    return err\n  } else {\n    // We could augment the message with \" [string exception]\" to indicate\n    // that the stack trace is not useful, or even set the .stack to null.\n    return new Error(err + '')\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-broccoli/node_modules/broccoli-source/index.js":"'use strict'\n\nexports.Directory = Directory\nfunction Directory(directoryPath, watched, options) {\n  if (typeof directoryPath !== 'string') throw new Error('Expected a path (string), got ' + directoryPath)\n  this._directoryPath = directoryPath\n  this._watched = !!watched\n\n  options = options || {}\n  this._name = options.name || (this.constructor && this.constructor.name) || 'Directory'\n  this._annotation = options.annotation\n\n  // Remember current call stack (minus \"Error\" line)\n  this._instantiationStack = (new Error).stack.replace(/[^\\n]*\\n/, '')\n}\n\nDirectory.prototype.__broccoliFeatures__ = Object.freeze({\n  persistentOutputFlag: true,\n  sourceDirectories: true\n})\n\nDirectory.prototype.__broccoliGetInfo__ = function(builderFeatures) {\n  if (builderFeatures == null) builderFeatures = { persistentOutputFlag: true, sourceDirectories: true }\n  if (!builderFeatures.persistentOutputFlag || !builderFeatures.sourceDirectories) {\n    throw new Error('Minimum builderFeatures required: { persistentOutputFlag: true, sourceDirectories: true }')\n  }\n\n  return {\n    nodeType: 'source',\n    sourceDirectory: this._directoryPath,\n    watched: this._watched,\n    instantiationStack: this._instantiationStack,\n    name: this._name,\n    annotation: this._annotation\n  }\n}\n\nDirectory.prototype.read = function(readTree) {\n  // Go through same interface as real Broccoli builder, so we don't have\n  // separate code paths\n\n  var pluginInterface = this.__broccoliGetInfo__()\n\n  if (pluginInterface.watched) {\n    return readTree(pluginInterface.sourceDirectory)\n  } else {\n    return pluginInterface.sourceDirectory\n  }\n}\n\nDirectory.prototype.cleanup = function() {\n}\n\nexports.WatchedDir = WatchedDir\nWatchedDir.prototype = Object.create(Directory.prototype)\nWatchedDir.prototype.constructor = WatchedDir\nfunction WatchedDir(directoryPath, options) {\n  Directory.call(this, directoryPath, true, options)\n}\n\nexports.UnwatchedDir = UnwatchedDir\nUnwatchedDir.prototype = Object.create(Directory.prototype)\nUnwatchedDir.prototype.constructor = UnwatchedDir\nfunction UnwatchedDir(directoryPath, options) {\n  Directory.call(this, directoryPath, false, options)\n}\n","/home/travis/build/npmtest/node-npmtest-broccoli/node_modules/broccoli-node-info/index.js":"'use strict'\n\n// This list of [feature, augmentationFunction] pairs is used to maintain\n// backwards compatibility with older broccoli-plugin versions.\n//\n// If a plugin doesn't support `feature`, then `augmentationFunction` is\n// called on its node info (as returned by node.__broccoliGetInfo__())\n// in order to bring the interface up-to-date. If a plugin is missing several\n// features, each `augmentationFunction` is applied in succession.\n//\n// Add new features to the bottom of the list.\nvar augmenters = [\n  [\n    'persistentOutputFlag', function(nodeInfo) {\n      nodeInfo.persistentOutput = false\n    }\n  ], [\n    'sourceDirectories', function(nodeInfo) {\n      nodeInfo.nodeType = 'transform'\n    }\n  ], [\n    'needsCacheFlag', function(nodeInfo) {\n      if (nodeInfo.nodeType === 'transform') {\n        nodeInfo.needsCache = true\n      }\n    }\n  ]\n]\n\nvar features = {}\nfor (var i = 0; i < augmenters.length; i++) {\n  features[augmenters[i][0]] = true\n}\nexports.features = features\n\n\nexports.getNodeInfo = getNodeInfo\nfunction getNodeInfo(node) {\n  // Check that `node` is in fact a Broccoli node\n  if (node == null || !node.__broccoliGetInfo__) {\n    if (typeof node === 'string') {\n      throw new InvalidNodeError('\"' + node + '\": String nodes are not supported. Use the WatchedDir class provided by the broccoli-source package instead.')\n    } else if (node != null && (typeof node.read === 'function' || typeof node.rebuild === 'function')) {\n      var legacyNodeDescription = node.description ||\n        node.constructor && node.constructor.name ||\n        ('' + node)\n      throw new InvalidNodeError(\n        legacyNodeDescription +\n        ': The .read/.rebuild API is no longer supported as of Broccoli 1.0. ' +\n        'Plugins must now derive from broccoli-plugin. ' +\n        'https://github.com/broccolijs/broccoli/blob/master/docs/broccoli-1-0-plugin-api.md')\n    } else {\n      throw new InvalidNodeError(node + ' is not a Broccoli node')\n    }\n  }\n\n  // Call __broccoliGetInfo__. Note that we're passing the builder's full\n  // feature set (the `features` variable) rather than the smaller feature set\n  // we'll be mimicking to interact with this plugin. This is a fairly\n  // arbitrary choice, but it's easier to implement, and it usually won't make\n  // a difference because the Plugin class won't care about features it\n  // doesn't know about.\n  var originalNodeInfo = node.__broccoliGetInfo__(features)\n\n  // Now, for backward compatibility, deal with plugins that don't implement\n  // our full feature set:\n\n  // 1. Make a shallow copy of the nodeInfo hash so we can modify it\n  //\n  // We don't to use prototypal inheritance (Object.create) because some test\n  // code can get confused if hasOwnProperty isn't true.\n  var nodeInfo = {}\n  for (var key in originalNodeInfo) {\n    nodeInfo[key] = originalNodeInfo[key]\n  }\n\n  // 2. Discover features we have in common\n  for (var i = 0; i < augmenters.length; i++) {\n    var feature = augmenters[i][0]\n    if (!node.__broccoliFeatures__[feature]) {\n      break\n    }\n  }\n\n  // 3. Augment the interface with the new features that the plugin doesn't support\n  for (; i < augmenters.length; i++) {\n    var fn = augmenters[i][1]\n    fn(nodeInfo)\n  }\n\n  // We generally trust the nodeInfo to be valid, but unexpected\n  // nodeTypes could break our code paths really badly, and some of those\n  // paths call rimraf, so we check this to be safe.\n  if (nodeInfo.nodeType !== 'transform' && nodeInfo.nodeType !== 'source') {\n    throw new InvalidNodeError('Unexpected nodeType: ' + nodeInfo.nodeType)\n  }\n\n  return nodeInfo\n}\n\n\nexports.InvalidNodeError = InvalidNodeError\nInvalidNodeError.prototype = Object.create(Error.prototype)\nInvalidNodeError.prototype.constructor = InvalidNodeError\nfunction InvalidNodeError(message) {\n  // Subclassing Error in ES5 is non-trivial because reasons, so we need this\n  // extra constructor logic from http://stackoverflow.com/a/17891099/525872.\n  var temp = Error.apply(this, arguments)\n  // Need to assign temp.name for correct error class in .stack and .message\n  temp.name = this.name = this.constructor.name\n  this.stack = temp.stack\n  this.message = temp.message\n}\n","/home/travis/build/npmtest/node-npmtest-broccoli/node_modules/broccoli/lib/load_brocfile.js":"var path = require('path')\nvar findup = require('findup-sync')\n\nmodule.exports = loadBrocfile\nfunction loadBrocfile () {\n  var brocfile = findup('Brocfile.js', {\n    nocase: true\n  })\n\n  if (brocfile == null) throw new Error('Brocfile.js not found')\n\n  var baseDir = path.dirname(brocfile)\n\n  // The chdir should perhaps live somewhere else and not be a side effect of\n  // this function, or go away entirely\n  process.chdir(baseDir)\n\n  var node = require(brocfile)\n\n  return node\n}\n","/home/travis/build/npmtest/node-npmtest-broccoli/node_modules/broccoli/lib/server.js":"var middleware = require('./middleware')\nvar http = require('http')\nvar connect = require('connect')\nvar printSlowNodes = require('broccoli-slow-trees')\n\nexports.serve = serve\nfunction serve (watcher, host, port) {\n  if (watcher.constructor.name !== 'Watcher') throw new Error('Expected Watcher instance')\n  if (typeof host !== 'string') throw new Error('Expected host to bind to (e.g. \"localhost\")')\n  if (typeof port !== 'number') throw new Error('Expected port to bind to (e.g. 4200)')\n\n  var server = {}\n\n  console.log('Serving on http://' + host + ':' + port + '\\n')\n\n  server.watcher = watcher\n  server.builder = server.watcher.builder\n\n  server.app = connect().use(middleware(server.watcher))\n\n  server.http = http.createServer(server.app)\n\n  // We register these so the 'exit' handler removing temp dirs is called\n  function cleanupAndExit() {\n    return server.watcher.quit()\n  }\n\n  process.on('SIGINT', cleanupAndExit)\n  process.on('SIGTERM', cleanupAndExit)\n\n  server.watcher.on('buildSuccess', function() {\n    printSlowNodes(server.builder.outputNodeWrapper)\n    console.log('Built - ' + Math.round(server.builder.outputNodeWrapper.buildState.totalTime) + ' ms @ ' + new Date().toString())\n  })\n\n  server.watcher.on('buildFailure', function(err) {\n    console.log('Built with error:')\n    console.log(err.message)\n    if (!err.broccoliPayload || !err.broccoliPayload.location.file) {\n      console.log('')\n      console.log(err.stack)\n    }\n    console.log('')\n  })\n\n  server.watcher.start()\n    .catch(function(err) {\n      console.log(err && err.stack || err)\n    })\n    .finally(function() {\n      server.builder.cleanup()\n      server.http.close()\n    })\n    .catch(function(err) {\n      console.log('Cleanup error:')\n      console.log(err && err.stack || err)\n    })\n    .finally(function() {\n      process.exit(1)\n    })\n\n  server.http.listen(parseInt(port, 10), host)\n  return server\n}\n","/home/travis/build/npmtest/node-npmtest-broccoli/node_modules/broccoli/lib/middleware.js":"var path = require('path')\nvar fs = require('fs')\n\nvar handlebars = require('handlebars')\nvar url = require('url')\nvar mime = require('mime')\n\nvar errorTemplate = handlebars.compile(fs.readFileSync(path.resolve(__dirname, 'templates/error.html')).toString())\nvar dirTemplate = handlebars.compile(fs.readFileSync(path.resolve(__dirname, 'templates/dir.html')).toString())\n\n// You must call watcher.start() before you call `getMiddleware`\n//\n// This middleware is for development use only. It hasn't been reviewed\n// carefully enough to run on a production server.\n//\n// Supported options:\n//   autoIndex (default: true) - set to false to disable directory listings\n//   liveReloadPath - LiveReload script URL for error pages\nmodule.exports = function getMiddleware(watcher, options) {\n  if (options == null) options = {}\n  if (options.autoIndex == null) options.autoIndex = true\n\n  var outputPath = watcher.builder.outputPath\n\n  return function broccoliMiddleware(request, response, next) {\n    if (watcher.currentBuild == null) {\n      throw new Error('Waiting for initial build to start')\n    }\n    watcher.currentBuild.then(function() {\n      var urlObj = url.parse(request.url)\n      var filename = path.join(outputPath, decodeURIComponent(urlObj.pathname))\n      var stat, lastModified, type, charset, buffer\n\n      // contains null byte or escapes directory\n      if (filename.indexOf('\\0') !== -1 || filename.indexOf(outputPath) !== 0) {\n        response.writeHead(400)\n        response.end()\n        return\n      }\n\n      try {\n        stat = fs.statSync(filename)\n      } catch (e) {\n        // not found\n        next()\n        return\n      }\n\n      if (stat.isDirectory()) {\n        var hasIndex = fs.existsSync(path.join(filename, 'index.html'))\n\n        if (!hasIndex && !options.autoIndex) {\n          next()\n          return\n        }\n\n        // If no trailing slash, redirect. We use path.sep because filename\n        // has backslashes on Windows.\n        if (filename[filename.length - 1] !== path.sep) {\n          urlObj.pathname += '/'\n          response.setHeader('Location', url.format(urlObj))\n          response.setHeader('Cache-Control', 'private, max-age=0, must-revalidate')\n          response.writeHead(301)\n          response.end()\n          return\n        }\n\n        if (!hasIndex) { // implied: options.autoIndex is true\n          var context = {\n            url: request.url,\n            files: fs.readdirSync(filename).sort().map(function (child){\n              var stat = fs.statSync(path.join(filename,child)),\n                isDir = stat.isDirectory()\n              return {\n                href: child + (isDir ? '/' : ''),\n                type: isDir ? 'dir' : path.extname(child).replace('.', '').toLowerCase()\n              }\n            }),\n            liveReloadPath: options.liveReloadPath\n          }\n          response.setHeader('Cache-Control', 'private, max-age=0, must-revalidate')\n          response.writeHead(200)\n          response.end(dirTemplate(context))\n          return\n        }\n\n        // otherwise serve index.html\n        filename += 'index.html'\n        stat = fs.statSync(filename)\n      }\n\n      lastModified = stat.mtime.toUTCString()\n      response.setHeader('Last-Modified', lastModified)\n      // nginx style treat last-modified as a tag since browsers echo it back\n      if (request.headers['if-modified-since'] === lastModified) {\n        response.writeHead(304)\n        response.end()\n        return\n      }\n\n      type = mime.lookup(filename)\n      charset = mime.charsets.lookup(type)\n      if (charset) {\n        type += '; charset=' + charset\n      }\n      response.setHeader('Cache-Control', 'private, max-age=0, must-revalidate')\n      response.setHeader('Content-Length', stat.size)\n      response.setHeader('Content-Type', type)\n\n      // read file sync so we don't hold open the file creating a race with\n      // the builder (Windows does not allow us to delete while the file is open).\n      buffer = fs.readFileSync(filename)\n      response.writeHead(200)\n      response.end(buffer)\n    }, function(buildError) {\n      // All errors thrown from builder.build() are guaranteed to be\n      // Builder.BuildError instances.\n      var context = {\n        stack: buildError.stack,\n        liveReloadPath: options.liveReloadPath,\n        payload: buildError.broccoliPayload\n      }\n      response.setHeader('Content-Type', 'text/html')\n      response.writeHead(500)\n      response.end(errorTemplate(context))\n    }).catch(function(err) { console.log(err.stack) })\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-broccoli/node_modules/broccoli-slow-trees/index.js":"function ellipsize(string, desiredLength) {\n  if (string.length > desiredLength) {\n    return string.slice(0, desiredLength - 3) + '...';\n  } else {\n    return string;\n  }\n}\n\nfunction printSlowNodes(nodeWrapper, factor) {\n  try {\n    var allSortResults = sortResults(nodeWrapper)\n    var flatSortedNodes = allSortResults.flatSortedNodes\n    var groupedSortedNodes = allSortResults.groupedSortedNodes\n\n    var minimumTime = nodeWrapper.buildState.totalTime * (factor || 0.05)\n    var logLines = [],\n        cumulativeLogLines = [];\n\n    var MAX_NAME_CELL_LENGTH = 45,\n        MAX_VALUE_CELL_LENGTH = 20;\n\n    for (var i = 0; i < flatSortedNodes.length; i++) {\n      var nw = flatSortedNodes[i]\n\n      if (nw.buildState.selfTime > minimumTime) {\n        logLines.push(pad(ellipsize(nw.label, MAX_NAME_CELL_LENGTH), MAX_NAME_CELL_LENGTH) + ' | ' + pad(Math.floor(nw.buildState.selfTime) + 'ms', MAX_VALUE_CELL_LENGTH))\n      }\n    }\n\n    if (logLines.length > 0) {\n      logLines.unshift(pad('', MAX_NAME_CELL_LENGTH, '-') + '-+-' + pad('', MAX_VALUE_CELL_LENGTH, '-'))\n      logLines.unshift(pad('Slowest Nodes', MAX_NAME_CELL_LENGTH) + ' | ' + pad('Total', MAX_VALUE_CELL_LENGTH))\n    }\n\n    for (var i = 0; i < groupedSortedNodes.length; i++) {\n      var group = groupedSortedNodes[i],\n          averageStr\n\n      if (group.totalSelfTime > minimumTime) {\n        if (group.nodeWrappers.length > 1) {\n          averageStr = ' (' + Math.floor(group.averageSelfTime) + ' ms)';\n        } else {\n          averageStr = '';\n        }\n\n        var countStr = ' (' + group.nodeWrappers.length + ')'\n        var nameStr = ellipsize(group.name, MAX_NAME_CELL_LENGTH - countStr.length)\n\n        cumulativeLogLines.push(pad(nameStr + countStr, MAX_NAME_CELL_LENGTH) + ' | ' + pad(Math.floor(group.totalSelfTime) + 'ms' + averageStr, MAX_VALUE_CELL_LENGTH))\n      }\n    }\n\n    if (cumulativeLogLines.length > 0) {\n      cumulativeLogLines.unshift(pad('', MAX_NAME_CELL_LENGTH, '-') + '-+-' + pad('', MAX_VALUE_CELL_LENGTH, '-'))\n      cumulativeLogLines.unshift(pad('Slowest Nodes (cumulative)', MAX_NAME_CELL_LENGTH) + ' | ' + pad('Total (avg)', MAX_VALUE_CELL_LENGTH))\n      cumulativeLogLines.unshift('\\n')\n    }\n\n    console.log('\\n' + logLines.join('\\n') + cumulativeLogLines.join('\\n') + '\\n')\n  } catch (e) {\n    console.error('Error when printing slow nodes:', e);\n    console.error(e.stack)\n  }\n}\n\nfunction sortResults(nodeWrapper) {\n  var flattenedNodes = []\n  var nodesGroupedByName = Object.create(null)\n  var groupedNodes = [];\n\n  function process(nw) {\n    if (flattenedNodes.indexOf(nw) > -1) { return } // for de-duping\n\n    flattenedNodes.push(nw)\n\n    if (nodesGroupedByName[nw.label] == null) {\n      nodesGroupedByName[nw.label] = {\n        name: nw.label,\n        nodeWrappers: [],\n        totalSelfTime: undefined, // to calculate\n        averageSelfTime: undefined // to calculate\n      }\n    }\n    nodesGroupedByName[nw.label].nodeWrappers.push(nw)\n\n    var length = nw.inputNodeWrappers.length\n    for (var i = 0; i < length; i++) {\n      process(nw.inputNodeWrappers[i])\n    }\n  }\n\n  process(nodeWrapper) // kick off with the top item\n\n  var flatSortedNodes = flattenedNodes.sort(function(a, b) {\n    return b.buildState.selfTime - a.buildState.selfTime\n  })\n\n  var numNodesThatAreUsedMoreThanOnce = 0;\n\n\n  for (var groupName in nodesGroupedByName) {\n    var group = nodesGroupedByName[groupName];\n\n    group.totalSelfTime = group.nodeWrappers.reduce(function(sum, nw) {\n      return sum + nw.buildState.selfTime\n    }, 0);\n\n    group.averageSelfTime = group.totalSelfTime / group.nodeWrappers.length;\n\n    groupedNodes.push(group);\n\n    if (group.nodeWrappers.length > 1) {\n      numNodesThatAreUsedMoreThanOnce += 1;\n    }\n  }\n\n  var flatSortedNodes = flattenedNodes.sort(function(a, b) {\n    return b.selfTime - a.selfTime\n  })\n\n  var groupedSortedNodes = [];\n\n  // Only return/show the grouped/cumulative results if there are some nodes used\n  // more than once.\n  if (numNodesThatAreUsedMoreThanOnce > 0) {\n    groupedSortedNodes = groupedNodes.sort(function(a, b) {\n      return b.totalSelfTime - a.totalSelfTime\n    })\n  }\n\n  return {\n    flatSortedNodes: flattenedNodes,\n    groupedSortedNodes: groupedSortedNodes\n  }\n}\n\nfunction pad(str, len, char, dir) {\n  if (!char) { char = ' '}\n\n  if (len + 1 >= str.length)\n    switch (dir){\n      case 'left':\n        str = Array(len + 1 - str.length).join(char) + str\n        break\n\n      case 'both':\n        var padlen = len - str.length\n        var right = Math.ceil(padlen / 2)\n        var left = padlen - right\n        str = Array(left + 1).join(char) + str + Array(right + 1).join(char)\n        break\n\n      default:\n        str = str + Array(len + 1 - str.length).join(char)\n    }\n\n  return str\n}\n\nmodule.exports = printSlowNodes\n","/home/travis/build/npmtest/node-npmtest-broccoli/node_modules/broccoli/lib/watcher.js":"'use strict'\n\nvar RSVP = require('rsvp')\nvar WatcherAdapter = require('./watcher_adapter')\nvar logger = require('heimdalljs-logger')('broccoli:watcher')\n\n// This Watcher handles all the Broccoli logic, such as debouncing. The\n// WatcherAdapter handles I/O via the sane package, and could be pluggable in\n// principle.\n\nmodule.exports = Watcher\nfunction Watcher(builder, options) {\n  this.options = options || {}\n  if (this.options.debounce == null) this.options.debounce = 100\n  this.builder = builder\n  this.watcherAdapter = new WatcherAdapter(this.options.saneOptions)\n  this.currentBuild = null\n  this._rebuildScheduled = false\n  this._ready = false\n  this._quitting = false\n  this._lifetimeDeferred = null\n}\n\nRSVP.EventTarget.mixin(Watcher.prototype)\n\nWatcher.prototype.start = function() {\n  var self = this\n\n  if (this._lifetimeDeferred != null) throw new Error('Watcher.prototype.start() must not be called more than once')\n  this._lifetimeDeferred = RSVP.defer()\n\n  this.watcherAdapter.on('change', this._change.bind(this))\n  this.watcherAdapter.on('error', this._error.bind(this))\n  RSVP.resolve().then(function() {\n    return self.watcherAdapter.watch(self.builder.watchedPaths)\n  }).then(function() {\n    logger.debug('ready')\n    self._ready = true\n    self.currentBuild = self._build()\n  }).catch(function(err) {\n    self._error(err)\n  })\n\n  return this._lifetimeDeferred.promise\n}\n\nWatcher.prototype._change = function() {\n  var self = this\n\n  if (!this._ready) {\n    logger.debug('change', 'ignored: before ready')\n    return\n  }\n  if (this._rebuildScheduled) {\n    logger.debug('change', 'ignored: rebuild scheduled already')\n    return\n  }\n  logger.debug('change')\n  this._rebuildScheduled = true\n  // Wait for current build, and ignore build failure\n  RSVP.resolve(this.currentBuild).catch(function() { }).then(function() {\n    if (self._quitting) return\n    var buildPromise = new RSVP.Promise(function(resolve, reject) {\n      logger.debug('debounce')\n      self.trigger('debounce')\n      setTimeout(resolve, self.options.debounce)\n    }).then(function() {\n      // Only set _rebuildScheduled to false *after* the setTimeout so that\n      // change events during the setTimeout don't trigger a second rebuild\n      self._rebuildScheduled = false\n      return self._build()\n    })\n    self.currentBuild = buildPromise\n  })\n}\n\nWatcher.prototype._build = function() {\n  var self = this\n\n  logger.debug('buildStart')\n  this.trigger('buildStart')\n  var buildPromise = self.builder.build()\n  // Trigger change/error events. Importantly, if somebody else chains to\n  // currentBuild, their callback will come after our events have\n  // triggered, because we registered our callback first.\n  buildPromise.then(function() {\n    logger.debug('buildSuccess')\n    self.trigger('buildSuccess')\n  }, function(err) {\n    logger.debug('buildFailure')\n    self.trigger('buildFailure', err)\n  })\n  return buildPromise\n}\n\nWatcher.prototype._error = function(err) {\n  var self = this\n\n  logger.debug('error', err)\n  if (this._quitting) return\n  this._quit().catch(function() { }).then(function() {\n    self._lifetimeDeferred.reject(err)\n  })\n}\n\nWatcher.prototype.quit = function() {\n  var self = this\n\n  if (this._quitting) {\n    logger.debug('quit', 'ignored: already quitting')\n    return\n  }\n  this._quit().then(function() {\n    self._lifetimeDeferred.resolve()\n  }, function(err) {\n    self._lifetimeDeferred.reject(err)\n  })\n}\n\nWatcher.prototype._quit = function(err) {\n  var self = this\n\n  this._quitting = true\n  logger.debug('quitStart')\n\n  return RSVP.resolve().then(function() {\n    return self.watcherAdapter.quit()\n  }).finally(function() {\n    // Wait for current build, and ignore build failure\n    return RSVP.resolve(self.currentBuild).catch(function() { })\n  }).finally(function() {\n    logger.debug('quitEnd')\n  })\n}\n","/home/travis/build/npmtest/node-npmtest-broccoli/node_modules/broccoli/lib/watcher_adapter.js":"var sane = require('sane')\nvar RSVP = require('rsvp')\nvar logger = require('heimdalljs-logger')('broccoli:watcherAdapter')\n\n\nfunction defaultFilterFunction(name) {\n  return /^[^\\.]/.test(name)\n}\n\nmodule.exports = WatcherAdapter\nRSVP.EventTarget.mixin(WatcherAdapter.prototype)\nfunction WatcherAdapter(options) {\n  this.options = options || {}\n  this.options.filter = this.options.filter || defaultFilterFunction\n}\n\nWatcherAdapter.prototype.watch = function(watchedPaths) {\n  var self = this\n\n  this.watchers = []\n  this.readyPromises = []\n  watchedPaths.forEach(function(watchedPath) {\n    var watcher = new sane(watchedPath, self.options)\n    function bindFileEvent(event) {\n      watcher.on(event, function(filepath, root, stat) {\n        logger.debug(event, root + '/' + filepath)\n        self.trigger('change')\n      })\n    }\n    bindFileEvent('change')\n    bindFileEvent('add')\n    bindFileEvent('delete')\n    watcher.on('error', function(err) {\n      logger.debug('error', err)\n      self.trigger('error', err)\n    })\n    var readyPromise = new RSVP.Promise(function(resolve, reject) {\n      watcher.on('ready', function() {\n        logger.debug('ready', watchedPath)\n        resolve()\n      })\n    })\n    self.watchers.push(watcher)\n    self.readyPromises.push(readyPromise)\n  })\n  return RSVP.Promise.all(this.readyPromises)\n}\n\nWatcherAdapter.prototype.quit = function () {\n  for (var i = 0; i < this.watchers.length; i++) {\n    this.watchers[i].close()\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-broccoli/node_modules/broccoli/lib/cli.js":"var fs = require('fs')\nvar program = require('commander')\nvar copyDereferenceSync = require('copy-dereference').sync\n\nvar broccoli = require('./index')\nvar Watcher = require('./watcher')\n\n\nmodule.exports = broccoliCLI\nfunction broccoliCLI () {\n  var actionPerformed = false\n  program\n    .version(JSON.parse(fs.readFileSync(__dirname + '/../package.json', 'utf8')).version)\n    .usage('[options] <command> [<args ...>]')\n\n  program.command('serve')\n    .description('start a broccoli server')\n    .option('--port <port>', 'the port to bind to [4200]', 4200)\n    .option('--host <host>', 'the host to bind to [localhost]', 'localhost')\n    .action(function(options) {\n      actionPerformed = true\n      broccoli.server.serve(new Watcher(getBuilder()), options.host, parseInt(options.port, 10))\n    })\n\n  program.command('build <target>')\n    .description('output files to target directory')\n    .action(function(outputDir) {\n      actionPerformed = true\n      if (fs.existsSync(outputDir)) {\n        console.error(outputDir + '/ already exists; we cannot build into an existing directory')\n        process.exit(1)\n      }\n      var builder = getBuilder()\n      builder.build()\n        .then(function() {\n          copyDereferenceSync(builder.outputPath, outputDir)\n        })\n        .finally(function () {\n          return builder.cleanup()\n        })\n        .then(function () {\n          process.exit(0)\n        })\n        .catch(function (err) {\n          // Should show file and line/col if present\n          if (err.file) {\n            console.error('File: ' + err.file)\n          }\n          console.error(err.stack)\n          console.error('\\nBuild failed')\n          process.exit(1)\n        })\n    })\n\n  program.parse(process.argv)\n  if(!actionPerformed) {\n    program.outputHelp()\n    process.exit(1)\n  }\n}\n\nfunction getBuilder () {\n  var node = broccoli.loadBrocfile()\n  return new broccoli.Builder(node)\n}\n"}